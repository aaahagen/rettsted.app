rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    // Checks if the user is the owner of the document (matching UID)
    // or if they have a matching organizationId in their token.
    function isMemberOf(orgId) {
      return isSignedIn() && (
        request.auth.token.organizationId == orgId || 
        request.auth.uid == orgId
      );
    }

    // Rules for the 'users' collection
    match /users/{userId} {
      allow read, create: if isSignedIn() && request.auth.uid == userId;
      allow update, delete: if false;
    }

    // Rules for the 'organizations' collection
    match /organizations/{orgId} {
      allow create: if isSignedIn() && request.auth.uid == orgId;
      allow read: if isMemberOf(orgId);
      allow update: if isSignedIn() && (resource.data.ownerId == request.auth.uid || request.auth.uid == orgId);
      allow delete: if false;
    }

    // Rules for the 'locations' collection
    match /locations/{locationId} {
      
      // GET: Allow if user belongs to the organization
      allow get: if isMemberOf(resource.data.organizationId);

      // LIST: Allow if the query is filtered by an organization the user belongs to.
      // We check both the token claim and the UID as a fallback for stability.
      allow list: if isSignedIn() && (
        request.query.where.get('organizationId')[2] == request.auth.token.organizationId ||
        request.query.where.get('organizationId')[2] == request.auth.uid
      );
      
      // WRITE: Allow if user is part of the organization they are writing to.
      allow create, update, delete: if isMemberOf(request.resource.data.organizationId || resource.data.organizationId);
    }

    // Catch-all deny
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
